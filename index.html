
<script>
/* ---- Kintra WhatsApp Insight Hotfix (non-destructive) ----
   Scope: Adds/restores Insight text for Smart Reply, synced with EN/IT and Before/After
   Safe to drop into any recent index variant. Only appends a container if missing.
----------------------------------------------------------- */

(function(){
  // 1) Insight text EN/IT
  const INSIGHT = {
    en: {
      before:
        "Generic chat tools don’t see your listings or client history. Agents re-type offers and often forget the next step.",
      after:
        "Kintra detects intent, drafts with your listing context, and surfaces a suggested next step. Auto-draft ~10–20 sec."
    },
    it: {
      before:
        "I tool generici non vedono gli annunci o lo storico del cliente. L’agente riscrive e spesso dimentica il prossimo passo.",
      after:
        "Kintra rileva l’intento, redige con il contesto dell’annuncio e propone il prossimo passo. Auto-bozza ~10–20 sec."
    }
  };

  // 2) Find Smart Reply area
  const waBody = document.querySelector('.wa-body') || document.querySelector('#wa-left')?.parentElement;
  if(!waBody) return; // nothing to do if the block isn't present

  // 3) Ensure an Insight container exists
  let insightEl = document.querySelector('#wa-insight');
  if(!insightEl){
    insightEl = document.createElement('div');
    insightEl.id = 'wa-insight';
    insightEl.className = 'insight';
    // prefer two-column layout: append as sibling to chat column if present
    const leftCol = document.querySelector('#wa-left');
    if (leftCol && leftCol.parentElement === waBody) {
      waBody.appendChild(insightEl);
    } else {
      // fallback: append at end of waBody
      waBody.appendChild(insightEl);
    }
  }

  // 4) A touch of styling (only if .insight not already styled)
  (function ensureInsightStyle(){
    const already = [...document.styleSheets].some(ss=>{
      try { return [...ss.cssRules].some(r => r.selectorText === '.insight'); } catch { return false; }
    });
    if(already) return;
    const st = document.createElement('style');
    st.textContent = `
      .insight{font-size:13px;color:#6b7280;border-left:3px solid #f59e0b;padding:10px 12px;border-radius:6px;background:#fff}
    `;
    document.head.appendChild(st);
  })();

  // 5) Helpers to detect current language & mode
  const getLang = () => (document.documentElement.lang === 'it' ? 'it' : 'en');
  const beforeBtn = document.querySelector('#wa-before');
  const afterBtn  = document.querySelector('#wa-after');

  // Try to infer mode from active button, else default to 'before'
  const getMode = () => {
    if (beforeBtn?.classList.contains('active')) return 'before';
    if (afterBtn?.classList.contains('active'))  return 'after';
    // some variants toggle via data-state or aria-pressed
    if (beforeBtn?.getAttribute('aria-pressed') === 'true') return 'before';
    if (afterBtn?.getAttribute('aria-pressed')  === 'true') return 'after';
    return 'before';
  };

  // 6) Update function
  function updateInsight(){
    const lang = getLang();
    const mode = getMode();
    const t = INSIGHT[lang]?.[mode] || '';
    insightEl.textContent = t;
  }

  // 7) Wire up: language toggle & before/after buttons
  // Language buttons (IDs used in your builds)
  const langEN = document.querySelector('#lang-en');
  const langIT = document.querySelector('#lang-it');

  langEN && langEN.addEventListener('click', () => setTimeout(updateInsight, 0));
  langIT && langIT.addEventListener('click', () => setTimeout(updateInsight, 0));

  // Before/After buttons
  beforeBtn && beforeBtn.addEventListener('click', () => setTimeout(updateInsight, 0));
  afterBtn  && afterBtn.addEventListener('click', () => setTimeout(updateInsight, 0));

  // 8) Also observe HTML lang changes (in case your setLang updates it directly)
  const mo = new MutationObserver(updateInsight);
  mo.observe(document.documentElement, { attributes:true, attributeFilter:['lang'] });

  // 9) First paint
  updateInsight();
})();
</script>
